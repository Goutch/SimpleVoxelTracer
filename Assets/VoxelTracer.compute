#pragma kernel CSMain

RWTexture2D<float4> OutputTexture;
int2 TextureResolution;

Buffer<int> VoxelData;
int3 VoxelDataResolution;
float VoxelSize;

float4x4 ViewRotation;
float3 ViewPosition;
float MaxDistance;

const uint MAX_ITERATIONS = 128;

int getIndex(uint x, uint y, uint z)
{
    return x * VoxelDataResolution.z * VoxelDataResolution.y + y * VoxelDataResolution.z + z;
}

float3 trace(float3 origin, float3 direction)
{
    //no division by 0
    if (direction.x == 0.)direction.x = .00000001f;
    if (direction.y == 0.)direction.y = .00000001f;
    if (direction.z == 0.)direction.z = .00000001f;

    float t = 0.;
    float3 minBound = float3(0., 0., 0.);
    float3 maxBound = float3(VoxelDataResolution * VoxelSize);
    //if origin outside the bounding box
    if (origin.x < minBound.x || origin.y < minBound.y || origin.z < minBound.z ||
        origin.x > maxBound.x || origin.y > maxBound.y || origin.z > maxBound.z)
    {
        //find the bounding box intersection point
        t = MaxDistance + 1.;
        float3 tMin = (minBound - origin) / direction;
        float3 tMax = (maxBound - origin) / direction;
        for (uint i = 0; i < 3; i++)
        {
            float3 p = direction * tMax[i] + origin;
            if (tMax[i] > 0 &&
                p[(i + 1) % 3] > minBound[(i + 1) % 3] && p[(i + 1) % 3] < maxBound[(i + 1) % 3] &&
                p[(i + 2) % 3] > minBound[(i + 2) % 3] && p[(i + 2) % 3] < maxBound[(i + 2) % 3])
            {
                t = min(t, tMax[i]);
            }
            p = direction * tMin[i] + origin;
            if (tMin[i] > 0 &&
                p[(i + 1) % 3] > minBound[(i + 1) % 3] && p[(i + 1) % 3] < maxBound[(i + 1) % 3] &&
                p[(i + 2) % 3] > minBound[(i + 2) % 3] && p[(i + 2) % 3] < maxBound[(i + 2) % 3])
            {
                t = min(t, tMin[i]);
            }
        }
    }

    //Begin tracing the ray along the voxel data
    for (uint i = 0; i < MAX_ITERATIONS; i++)
    {
        if (VoxelData[0] == 1)
        {
            return float3(1., 1., 1.);
        }
        if (t > MaxDistance)
            break;
        /* float3 position = direction * t + origin;
         int index = getIndex(uint(position.x % VoxelDataResolution.x),
                              uint(position.y % VoxelDataResolution.y),
                              uint(position.z % VoxelDataResolution.z));*/
    }
    return float3(0., 0., 0.);
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float2 uv = float2(id.x, id.y) / float2(TextureResolution.x, TextureResolution.y);
    uv -= 0.5;
    uv.y *= float(TextureResolution.y) / float(TextureResolution.x);

    float3 dir = float3(uv.x, uv.y, 1.);
    float3 origin = ViewPosition;

    dir = mul(ViewRotation, float4(dir.x, dir.y, dir.z, 1.)).xyz;
    dir = normalize(dir);
    OutputTexture[id.xy] = float4(trace(origin, dir), 1);
}
